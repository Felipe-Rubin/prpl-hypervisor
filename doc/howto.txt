Hypervisor Deployment on PIC32MZ2048EFM144 platform.


%!target  : html
%!encoding: utf-8
%!style  : tutorial.css
%!options : --toc --enum-title --css-inside


= Introduction =

This how-to is intended to show how to compile the hypervisor with a virtualized bare-metal application the PIC32MZ2048EFM144 Microchip SoC without using the MPLABX compiler or linker scripts.


= Pre-Requisits =

 - Ubuntu 14.04 LTS or greater. It should work on Debian as well. 
 - PIC32MZ Embedded Connectivity Starter Kit board and cables. 

 
== Ubuntu tools requirements ==

Install the following software packages on Ubuntu 14.04 LTS.

```
sudo dpkg --add-architecture i386
sudo apt-get update
sudo apt-get install gcc-multilib
sudo apt-get install libc6:i386 libncurses5:i386 libstdc++6:i386
sudo apt-get install libexpat1-dev:i386
sudo apt-get install libX11-dev:i386
sudo apt-get install libXext-dev:i386
```


= Thrid part software and tools =


- MPLABX IPE already installed (used to flash the bootloader for the first time). You don't need the MPLABX IDE installed, just the IPE. (http://microchip.wikidot.com/ipe:installation)
- MIPS-MTI toolchain already installed. (Download page: https://community.imgtec.com/developers/mips/tools/codescape-mips-sdk/download-codescape-mips-sdk-essentials/)
- pic32prog to flash the hypervisor and VMs (Source code: https://github.com/sergev/pic32prog)
- git client installed (sudo apt-get install git). 
- Installed srecord software package (sudo apt-get install srecord)


== pic32prog download ==

```
Linux64: https://github.com/sergev/pic32prog/blob/master/linux64/pic32prog
Linux32: https://github.com/sergev/pic32prog/blob/master/linux32/pic32prog
```

Download and copy the pic32prog to the prplHypervisor directory that will be created at step 4.1.


== Remove ModemManager software package ==

The ModemManager software package scans for modems on individual serial ports when they are plugged, e.g. ttyACM ports. This keeps the port busy for several seconds. To avoid this inconvenience uninstall it from your system:

```
sudo apt-get purge modemmanager.
```
 

= Deployment =


1) Clone the git repository of the prplHypervisor and make sure you are at master branch:

```
git clone https://github.com/prplfoundation/prpl-hypervisor
git checkout master 
```

2) Use the MPLABX IPE to flash the Microchip_UART.hex to the board. It can be found at the prplHypervisor/bin directory.
    - The bootloader was generated from the project https://github.com/chipKIT32/PIC32-avrdude-bootloader. 
    - After flashed, the LED1 will keep blinking showing the that the bootloader is ready to upload a hex file.


3) At the prplHypervisor directory use the make command to compile the hypervisor and the sample bare-metal application using the MIPS-MTI toolchain. This process will generate the firmware.bin file. Such file contains the 
hypervisor and the VM's code. 

```
~/prplHypervisor$: make
mips-mti-elf-gcc -EL -O2 -c -mips32r2 -mtune=m14k -Wa,-mvirt -mno-check-zero-division -msoft-float -fshort-double -ffreestanding -nostdlib -fomit-frame-pointer -G 0 -I include/ -I ./hal/include/ -DCPU_SPEED=200000000  -c hal/microchip/boot.S -o hal/microchip/boot.o
mips-mti-elf-gcc -EL -O2 -c -mips32r2 -mtune=m14k -Wa,-mvirt -mno-check-zero-division -msoft-float -fshort-double -ffreestanding -nostdlib -fomit-frame-pointer -G 0 -I include/ -I ./hal/include/ -DCPU_SPEED=200000000  -c kernel.c -o kernel.o

...

mips-mti-elf-objdump -s apps/uart.elf > apps/uart.cnt
mips-mti-elf-objcopy -O binary apps/uart.elf apps/uart.bin
mips-mti-elf-size apps/uart.elf
   text    data     bss     dec     hex filename
   8244      16       8    8268    204c apps/uart.elf
make[1]: Leaving directory `/home/crmoratelli/hyper/prplHypervisor/bare-metal-apps'
./genhex.sh uart;
0+1 records in
1+0 records out
65536 bytes (66 kB) copied, 0,000201578 s, 325 MB/s
0+1 records in
1+0 records out
65536 bytes (66 kB) copied, 0,000179478 s, 365 MB/s
```


4) Upload the resulting firwarem.hex file to the board using "make load" command. For this, use a second USB cable to connect to the board's UART port. 

```
~/prplHypervisor$: make load
stty 115200 raw cs8 -hupcl -parenb -crtscts clocal cread ignpar ignbrk -ixon -ixoff -ixany -brkint -icrnl -imaxbel -opost -onlcr -isig -icanon -iexten -echo -echoe -echok -echoctl -echoke -F /dev/ttyACM0
./pic32prog -S -d /dev/ttyACM0 firmware.hex
Programmer for Microchip PIC32 microcontrollers, Version 2.0.186
    Copyright: (C) 2011-2015 Serge Vakulenko
      Adapter: STK500v2 Bootloader
 Program area: 1d000000-1d1fffff
    Processor: Bootloader
 Flash memory: 2048 kbytes
  Boot memory: 80 kbytes
         Data: 131072 bytes
        Erase: done
Program flash: ################################# done
 Program rate: 6600 bytes per second
```

5) You can make a cat command to the ttyACM0 dev to see the application output. 

```
===========================================================
prplHypervsior v0.0.3 (gbf3f35d) [Jul 10 2016, 11:52:12]
Copyright (c) 2016, prpl Foundation
===========================================================
CPU ID:        M5150
ARCH:          Microchip Starter Kit
SYSCLK:        200MHz
Heap size:     32Kbytes
Scheduler      1ms
VMs:           2
Initializing Physical Processor.
Initializing Virtual Machines
Creating VCPUs
Creating VCPUs
Configuring Timer
Starting Hypervisor Execution

ping VM ID 1
Target VCPU not initialized.
Targe
pong VM ID 2t VCPU not initialized.
pong VM: message from VM ID 1: "ping? 6" (8 bytes)
ping VM: message from VM ID 2: "pong!" (6 bytes)
pong VM: message from VM ID 1: "ping? 13" (9 bytes)
ping VM: message from VM ID 2: "pong!" (6 bytes)
pong VM: message from VM ID 1: "ping? 18" (9 bytes)
```


= Bare-metal application development=

To develop new applications move to the ~/prplHypervisor/bare-metal-apps/apps directory and see the uart.c, blink.c, ping.c among others examples. This is the code that is virtualized and executed when the file firmware.hex is flashed to the board.

The hypervisor can on for up to 3 bare-metal applications (virtual machines). Each virtual machine has 64Kb of SRAM and 32Kb of flash code. Virtual machines with more hardware capacity can be added. But, this requires a different configuration file (config.h). Contact the PUCRS team for support. 

To configure the environment to generate a system configuration with a different number of VMs is necessary a minor modification at the main Makefile. Thus,
open the file ~/prplHypervisor/Makefile and modify the variable APP_LIST. This variable must contain the names of the desired bare-metal applications. The following example generates a virtualized system with the applications uart, arm-control, and blink. 

```
#List of bare-metal applications 
APP_LIST= uart arm-control blink
```

== Timer ==

The default hypervisor scheduler quantum is ten milliseconds. Thus, each VM will perform during ten milliseconds before to be preempted to the next VM execution. During its execution, the VM will receive timer interrupts each one millisecond.  

The implementation of the timer handler at the VM is done in the irq_timer() function. 


= Inter-VM Communication =

The prplHypervisor supports Inter-VM communication through message copies from origin to the target VM. The API is simple and consists of the following calls:

```
int32_t ReceiveMessage(uint32_t *source, char* buffer, uint32_t bufsz, uint32_t block);
uint32_t SendMessage(uint32_t target, char* buffer, uint32_t size);
```

Each VM has an identification number (ID) generated by the hypervisor during its initialization. The ID is attributed following the VM's initialization order. The first initialized VM has ID equal to 1, the second one has ID 2 and so on. 
The ID is used to identify the VMs during communication. A VM can discovers its on ID calling the hypercall hyp_get_guest_id(). 

The ReiceveMessage() hypercall returns greater than 0 if a message was received. The data is copied to the buffer limited to bufsz bytes. Zero means no data was received.  The SendMessage() hypercall returns the number of bytes sent. Zero or less means error. The possible errors are:
MESSAGE_VCPU_NOT_FOUND (destination not found), MESSAGE_FULL (destination queue full), MSSAGE_TOO_BIG (message to big), MESSAGE_VCPU_NOT_INIT (the target VPCU is not ready for communication).

If nonblocking receive is desired, use block equal to zero when calling ReceiveMessage(), otherwise, it will block the application until a message is received. 

The application Ping-Pong is an example for inter-VM communication. A message is sent from ping (VM ID 1) to pong (VM ID 2) and back. To compile the Ping-Pong example, it is needed to modify the APP_LIST variable in the main makefile (prplHypervisor/Makefile) to:

```
APP_LIST=  ping pong
```


==Overall API available to VMs==

The bare-metal application's execution enviroment supports a minimal Unix-like API. The available functions are listeb below: 

```
int8_t *strcpy(int8_t *dst, const int8_t *src);
int8_t *strncpy(int8_t *s1, int8_t *s2, int32_t n);
int8_t *strcat(int8_t *dst, const int8_t *src);
int8_t *strncat(int8_t *s1, int8_t *s2, int32_t n);
int32_t strcmp(const int8_t *s1, const int8_t *s2);
int32_t strncmp(int8_t *s1, int8_t *s2, int32_t n);
int8_t *strstr(const int8_t *string, const int8_t *find);
int32_t strlen(const int8_t *s);
int8_t *strchr(const int8_t *s, int32_t c);
int8_t *strpbrk(int8_t *str, int8_t *set);
int8_t *strsep(int8_t **pp, int8_t *delim);
int8_t *strtok(int8_t *s, const int8_t *delim);
void *memcpy(void *dst, const void *src, uint32_t n);
void *memmove(void *dst, const void *src, uint32_t n);
int32_t memcmp(const void *cs, const void *ct, uint32_t n);
void *memset(void *s, int32_t c, uint32_t n);
int32_t strtol(const int8_t *s, int8_t **end, int32_t base);
int32_t atoi(const int8_t *s);
int8_t *itoa(int32_t i, int8_t *s, int32_t base);
int32_t puts(const int8_t *str);
int8_t *gets(int8_t *s);
int32_t abs(int32_t n);
int32_t random(void);
void srand(uint32_t seed);
int printf(const int8_t *fmt, ...);
int sprintf(int8_t *out, const int8_t *fmt, ...);
void udelay(uint32_t usec);
void putchar(int32_t value);
uint32_t getchar(void);
```


== UART access ==

I/O calls, like printf() or getchar() will assume by default the UART2 port (J11 connector). However, the application on a VM can choose to write to the UART6 (PIN 12 TX and PIN 11 RX of the 40 pin connector ). To this use the following call:

```
int32_t serial_select(uint32_t serial_number);
```

Use the defined parameters UART2 and UART6 to select each one of the UARTS. 

= Considerations =

- If the hypervisor is executing, it is possible to reset the board to upload a new firmware without turn off the board. To do this, just press the button SW1 on the board. However, if the hypervisor is not in execution to flash a new software will require turning off the board.
- On power on, the board will wait for 5 seconds before automatically load the application. During this time it is possible to flash a new firmware. 



