#include <stdio.h>
#include <stdlib.h>
#include <libconfig.h>
#include <string.h>
#include <stdarg.h>

#define STRSZ 128
#define OUTFILE "../include/config.h"
#define DEBUG_COMMENT "/* Debug UART prints */\n"
#define SYSTEM_COMMENT "/* Hypervisor kernel configuration and board info */\n"

/* Intermediate Physical address of the first VM on the RAM */
#define VMS_RAM_INTERMEDIATE_BASE_ADDRESS 0x80010000
#define VMS_RAM_VIRTUAL_BASE_ADDRESS  0x80000000


#define DEBUG
#ifdef DEBUG
#define debug(fmt, ...) fprintf(stderr, fmt, __VA_ARGS__)
#else
#define debug(...) do{ }while(0)
#endif

/* Struct for translation between const names and values */
struct mem_sizes_def{
    unsigned int size;
    char name[128];
};

/* Pages mask definition used by the hypervisor */
const struct mem_sizes_def PageSizes[] = {
    {name: "PAGEMASK_4KB",    size: 4096},
    {name: "PAGEMASK_16KB",   size: 16384},
    {name: "PAGEMASK_64KB",   size: 65536},
    {name: "PAGEMASK_256KB",  size: 262144},
    {name: "PAGEMASK_1MB",    size: 1048576},    
    {name: "PAGEMASK_4MB",    size: 4194304},    
    {name: "PAGEMASK_16MB",   size: 16777216},    
    {name: "PAGEMASK_256MB",  size: 268435456}
};

/* Memory areas definition used in the config file. */
const struct mem_sizes_def MemSizes[] = {
    {name: "MEM_SIZE_4KB",    size: 4096},
    {name: "MEM_SIZE_16KB",   size: 16384},
    {name: "MEM_SIZE_32KB",   size: 32768},
    {name: "MEM_SIZE_64KB",   size: 65536},
    {name: "MEM_SIZE_128KB",  size: 131072},    
    {name: "MEM_SIZE_256KB",  size: 262144},    
    {name: "MEM_SIZE_512KB",  size: 524288},    
    {name: "MEM_SIZE_1MB",    size: 1048576}
};    


/**
 * @brief Write to the configuration file.
 * @param f output file.
 * @param str string containing the output text.
 * @return 0 when sucessfull or EXIT_FAILURE in case of error. 
 */
int write_to_conf_file(FILE *f, char* str){ 
    int size = strlen(str);
    if (fwrite(str, sizeof(char), size, f) != size){
        perror("fwrite(): ");
        return EXIT_FAILURE;
    }
    return 0;
}

/**
 * @brief Generate initial message on top of the config.h file.
 * @param f output file.
 * @param conf_name Input configuration file name.
 * @return 0 when sucessfull or EXIT_FAILURE in case of error. 
 */
int initial_msg(FILE *f, char * conf_name){
    if (write_to_conf_file(f, "/* THIS FILE IS AUTOMATICALLY GENERATED. DO NOT MODIFY IT. */\n"))
        return EXIT_FAILURE;
    
    if(write_to_conf_file(f, "/* See the input xml in "))
        return EXIT_FAILURE;
    
    if (write_to_conf_file(f, conf_name))
        return EXIT_FAILURE;
    
    if (write_to_conf_file(f, " */\n\n"))
        return EXIT_FAILURE;
    
    return 0;
}

/**
 * @brief Concatenate a list of strings
 * @param dest Destination string.
 * @param size Size of the destination string.
 * @param ... Variable number of strings .
 * @return Pointer to the destination string. 
 */
char* strings_cat(char *dest, int size, ...){
    va_list arguments;
    char *c;
    int total = 0;
    
    memset(dest, 0, size);
    
    va_start(arguments, size); 
    
    while( c = va_arg(arguments, char*)){
        total+=strlen(c);
        if (total > size)
            break;
        strcat(dest, c);
    }
    
    va_end(arguments);
    
    return dest;
}


/**
 * @brief Insert blank line in the ouput file.
 * @param f output file.
 * @return Pointer to the destination string. 
 */
int insert_blank_line(FILE *f){
    if ( write_to_conf_file(f, "\n")) {
        return EXIT_FAILURE;
    }
    return 0;
}

/* Generate general system configuration 
 * @param cfg: input configuration.
 */
int gen_system_configuration(config_t cfg, FILE* outfile){
    config_setting_t *setting;
    int num_el, i;
    int ret;
    char str[STRSZ];
    char auxstr[STRSZ];
    const char *auxstrp;
    int value;
    
    /* get debug flags . */
    setting = config_lookup(&cfg, "system.debug");
    if(setting){
        num_el = config_setting_length(setting);
        int i;
        
        if ( ret = write_to_conf_file(outfile, DEBUG_COMMENT)) {
            return ret;
        }
        
        for(i = 0; i < num_el; ++i)
        {
            const char* debug_flag = config_setting_get_string_elem(setting, i);
            strings_cat(str, STRSZ, "#define ", debug_flag, "\n", NULL);
            if ( ret = write_to_conf_file(outfile, str)) {
                return ret;
            }
        }
    }
    
    if (ret = insert_blank_line(outfile)){
        return ret;
    }
    
    /* Insert system configuration comment */
    if ( ret = write_to_conf_file(outfile, SYSTEM_COMMENT)) {
        return ret;
    }
    
    /* get platform info*/
    setting = config_lookup(&cfg, "system.platform");
    if(setting){
        /* CPU_ID */
        if (config_setting_lookup_string(setting, "cpu", &auxstrp)){
            strings_cat(str, STRSZ, "#define CPU_ID ", "\"", auxstrp, "\"\n", NULL);
            if ( ret = write_to_conf_file(outfile, str)) {
                return ret;
            }
        }else{
            fprintf(stderr, "Missing cpu configuration on system.platform group.\n");
            return EXIT_FAILURE;
        }

        /*CPU_ARCH */
        if (config_setting_lookup_string(setting, "platform_str", &auxstrp)){
            strings_cat(str, STRSZ, "#define CPU_ARCH ", "\"", auxstrp, "\"\n", NULL);
            if ( ret = write_to_conf_file(outfile, str)) {
                return ret;
            }
        }else{
            fprintf(stderr, "Missing platform_str configuration on system.platform group.\n");
            return EXIT_FAILURE;
        
        }

        /*CPU_FREQ */
        if (config_setting_lookup_int(setting, "system_clock", &value)){
            snprintf(auxstr, STRSZ, "%d", value);
            strings_cat(str, STRSZ, "#define CPU_FREQ ", auxstr, "\n", NULL);
            if ( ret = write_to_conf_file(outfile, str)) {
                return ret;
            }
            
            /* MILISECOND */
            snprintf(auxstr, STRSZ, "%d", value/2);
            strings_cat(str, STRSZ, "#define MILISECOND ", "(", auxstr, "/ 1000)", "\n", NULL);
            if ( ret = write_to_conf_file(outfile, str)) {
                return ret;
            }
        }else{
            fprintf(stderr, "Missing system_clock configuration on system.platform group.\n");
            return EXIT_FAILURE;
            
        }
    }
    else{
        fprintf(stderr, "Missing platform configuration on system group.\n");
        return EXIT_FAILURE;
    } /*end platform configuration  */
    
    /* UART speed */
    if (config_lookup_int(&cfg, "system.uart_speed", &value)){
        snprintf(auxstr, STRSZ, "%d", value);
        strings_cat(str, STRSZ, "#define UART_SPEED ", auxstr, "\n", NULL);
        if ( ret = write_to_conf_file(outfile, str)) {
            return ret;
        }
    }
       
    /* scheduler_quantum_ms  */
    if (config_lookup_int(&cfg, "system.scheduler_quantum_ms", &value)){
        snprintf(auxstr, STRSZ, "%d", value);
        strings_cat(str, STRSZ, "#define QUANTUM (", auxstr, " * MILISECOND)", "\n", NULL);
        if ( ret = write_to_conf_file(outfile, str)) {
            return ret;
        }
    }
       
    /* heap_size_bytes  */
    if (config_lookup_int(&cfg, "system.heap_size_bytes", &value)){
        snprintf(auxstr, STRSZ, "0x%x", value);
        strings_cat(str, STRSZ, "#define HEAP_SIZE " , auxstr, "\n", NULL);
        if ( ret = write_to_conf_file(outfile, str)) {
            return ret;
        }
    }

    /* heap_address  */
    if (config_lookup_int(&cfg, "system.heap_address", &value)){
        snprintf(auxstr, STRSZ, "0x%x", value);
        strings_cat(str, STRSZ, "#define HEAP_ADDRESS " , auxstr, "\n", NULL);
        if ( ret = write_to_conf_file(outfile, str)) {
            return ret;
        }
    }
    
    if (ret = insert_blank_line(outfile)){
        return ret;
    }
    
    
}

int main(int argc, char **argv)
{
    config_t cfg;
    config_setting_t *setting;
    const char *str;
    int uart_speed;
    FILE* outfile;
    
    if (argc<2){
        fprintf(stderr, "Usage: %s <config file path>\n", argv[0]);
        return EXIT_FAILURE;
    }
        
    config_init(&cfg);
    
    /* Read the file. If there is an error, report it and exit. */
    if(! config_read_file(&cfg, argv[1]))
    {
        fprintf(stderr, "%s:%d - %s\n", config_error_file(&cfg),
                config_error_line(&cfg), config_error_text(&cfg));
        config_destroy(&cfg);
        return(EXIT_FAILURE);
    }
    
    /* output file (config.h) */
    if(NULL == (outfile = fopen(OUTFILE, "w"))){
        fprintf(stderr, "Error creating %s file.", OUTFILE);
        config_destroy(&cfg);
        return(EXIT_FAILURE);
    }
    
    if (initial_msg(outfile, argv[1])){
        config_destroy(&cfg);
        fclose(outfile);
        return(EXIT_FAILURE);
    }
    
    if (gen_system_configuration(cfg, outfile)){
        config_destroy(&cfg);
        fclose(outfile);
        return(EXIT_FAILURE);
    }
         
    fclose(outfile);
    config_destroy(&cfg);
    return(EXIT_SUCCESS);
}

/* eof */
